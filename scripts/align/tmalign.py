from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Align import MultipleSeqAlignment
from Bio.Alphabet import generic_protein

from MyBio.util import (try_parse_from_pdb, try_save_2pdb)

from util.file import (is_directory_valid, is_file_valid)
from util.exceptions import InvalidSuperpositionFileError
from os import remove

import math
import glob
import subprocess
import os.path
import warnings

import logging
logger = logging.getLogger(__name__)


TMALIGN = "/bin/tmalign"


def run_tmalign(file1, file2, output_path, tmalign):

    logger.info("Trying to execute the command: '%s %s %s'." % (tmalign, file1, file2))

    for fname in (file1, file2):
        if not os.path.isfile(fname):
            logging.error("Missing file: %s", fname)
            raise FileNotFoundError("Missing file: %s", fname)

    try:
        if (output_path is not None and output_path.strip() != ""):
            if (is_directory_valid(output_path)):
                logger.info("The superposition files will be saved "
                            "at the directory '%s'" % output_path)

                filename = os.path.split(os.path.basename(file1))[1]
                output_file = "%s/%s.sup" % (output_path, filename)
                args = [tmalign, file1, file2, "-o", output_file]
        else:
            args = [tmalign, file1, file2]

        output = subprocess.check_output(args)
    except subprocess.CalledProcessError as e:
        logger.exception("%s TMalign failed (returned %s):\n%s" % (e.returncode, e.output))

        raise RuntimeError("TMalign failed for PDB files: %s %s" % (file1, file2))

    return output.decode()


def get_seq_records(tm_output, ref_id, eqv_id):
    """Create a pair of SeqRecords from TMalign output."""

    logger.info("Parsing the TMalign output.")

    lines = tm_output.splitlines()

    # Extract the TM-score (measure of structure similarity)
    # Take the mean of the (two) given TM-scores -- not sure which is reference
    tmScores = []
    for line in lines:
        if line.startswith('TM-score'):
            # TMalign v. 2012/05/07 or earlier
            tmScores.append(float(line.split(None, 2)[1]))
        elif 'TM-score=' in line:
            # TMalign v. 2013/05/11 or so
            tokens = line.split()
            for token in tokens:
                if token.startswith('TM-score='):
                    _key, _val = token.split('=')
                    tmScores.append(float(_val.rstrip(',')))
                    break

    tmScore = math.fsum(tmScores) / len(tmScores)
    # Extract the sequence alignment
    lastLines = lines[-7:]

    assert lastLines[0].startswith('(":"')  # (":" denotes the residues pairs
    assert lastLines[-1].startswith('Total running time is')

    refSeq, eqvSeq = lastLines[1].strip(), lastLines[3].strip()

    return (SeqRecord(Seq(refSeq), id=ref_id, description="TMalign TM-score=%f" % tmScore),
            SeqRecord(Seq(eqvSeq), id=eqv_id, description="TMalign TM-score=%f" % tmScore))


def align_2struct(file1, file2, output_path=None, tmalign=None):

    if (tmalign is None):
        tmalign = TMALIGN

    output = run_tmalign(file1, file2, output_path, tmalign)

    seq_pair = get_seq_records(output, file1, file2)

    alignment = MultipleSeqAlignment(seq_pair, generic_protein)

    return alignment


def extract_chain_from_sup(sup_file, extract_chain, new_chain_id, output_file, QUIET=False):
    """ Extract a chain from the superposition file generated with TMAlign.
        TMAlign modifies the name of the chains, so it is highly
        recommended to rename a chain's name before to create the output file.

        @param sup_file: a superposition file generated with TMAlign.
        @type sup_file: string

        @param extract_chain: target chain to be extracted.
        @type extract_chain: string

        @param new_chain_id: the new name to the extracted chain.
        @type new_chain_id: string

        @param output_file: the name to the extracted PDB file.
        @type  output_file: string

        @param QUIET: mutes warning messages generated by Biopython.
        @type QUIET: boolean
    """
    if QUIET:
        try:
            warnings.filterwarnings("ignore")
            logger.info("Quiet mode activated. From now on, no warning will be printed.")
        except Exception:
            logger.warning("Quiet mode could not be activated.")

    try:
        if (is_file_valid(sup_file)):
            logger.info("Trying to parse the file '%s'." % sup_file)

            structure = try_parse_from_pdb("SUP", sup_file)

            model = structure[0]
            if (len(model.child_list) != 2):
                raise InvalidSuperpositionFileError("This structure has %d chains. The file generated "
                                                    "by TMAlign must have 2 chains." % len(model.child_list))

            chainToRemove = 'B' if (extract_chain == "A") else "A"
            model.detach_child(chainToRemove)
            if (extract_chain != new_chain_id):
                model[extract_chain].id = new_chain_id
            logger.info("Modifications completed.")

            logger.info("Now, it will try to parse the file '%s'." % sup_file)

            try_save_2pdb(structure, output_file)

            logger.info("File '%s' created successfully." % output_file)
    except Exception as e:
        logger.exception(e)
        raise


def remove_sup_files(path):
    """ Remove all superposition files created by TMAlign at a defined directory.

        @param path: a path to remove superposition files.
        @type path: string
    """
    try:
        if (is_directory_valid(path)):
            targets = ['*.sup', '*.sup_atm', '*.sup_all', '*.sup_all_atm', '*.sup_all_atm_lig']

            for target in targets:
                files = glob.glob('%s/%s' % (path, target))
                for file in files:
                    try:
                        remove(file)
                    except Exception as e:
                        logger.exception(e)
                        logger.warning("File %s not removed." % file)
    except Exception as e:
        logger.exception(e)
        raise
